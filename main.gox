package main

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"time"

	"github.com/FactomProject/FactomCode/common"
	"github.com/FactomProject/FactomCode/database"
	"github.com/FactomProject/FactomCode/database/ldb"
	"github.com/FactomProject/FactomCode/factomlog"
	"github.com/FactomProject/factom"
	"github.com/FactomProject/factomizer/primitives"

	"github.com/btcsuitereleases/btcd/btcjson"
	"github.com/btcsuitereleases/btcd/chaincfg"
	"github.com/btcsuitereleases/btcd/txscript"
	"github.com/btcsuitereleases/btcd/wire"
	"github.com/btcsuitereleases/btcrpcclient"
	"github.com/btcsuitereleases/btcutil"
	"github.com/davecgh/go-spew/spew"
)

var (
	zeroID           = "0000000000000000000000000000000000000000000000000000000000000000"
	myMonitor        = Monitor{Height: 0}
	balances         []balance // unspent balance & address & its WIF
	dirBlockInfoMap  = make(map[string]*common.DirBlockInfo) //DBMerkleRoot string as key
	db               database.Db
	dblocks          []DBlock
	reAnchorAfter    = 4  // hours. For anchors that do not get bitcoin callback info for over 10 hours, then re-anchor them.
	tenMinutes       = 10 // 10 minute mark
	defaultAddress   btcutil.Address
	minBalance       btcutil.Amount
	noBalanceString  = "\n\n$$$ WARNING: No balance in your wallet. No anchoring for now.\n"

	fee                 btcutil.Amount // tx fee for written into btc
	confirmationsNeeded int

	//Server Private key for milestone 1
	serverPrivKey    common.PrivateKey
	serverPrivKeyHex string
	serverPubKey     common.PublicKey

	//Server Entry Credit private key
	//serverECKey common.PrivateKey
	//Anchor chain ID
	anchorChainID *common.Hash

	//Logger
	anchorLog *factomlog.FLogger
)

type Monitor struct {
	Height       int
	BlockHead    string
	DeepestBlock string
}

type DBlock struct {
	PrevBlockKeyMR string
	Timestamp      uint64
	SequenceNumber int

	//BlockTimeStr string
	KeyMR string
}

type balance struct {
	unspentResult btcjson.ListUnspentResult
	address       btcutil.Address
	wif           *btcutil.WIF
}

//AnchorRecord is used to construct anchor chain
type AnchorRecord struct {
	AnchorRecordVer int
	DBHeight        uint32
	KeyMR           string
	RecordHeight    uint32

	Bitcoin struct {
		Address     string //"1HLoD9E4SDFFPDiYfNYnkBLQ85Y51J3Zb1",
		TXID        string //"9b0fc92260312ce44e74ef369f5c66bbb85848f2eddd5a7a1cde251e54ccfdd5", BTC Hash - in reverse byte order
		BlockHeight int32  //345678,
		BlockHash   string //"00000000000000000cc14eacfc7057300aea87bed6fee904fd8e1c1f3dc008d4", BTC Hash - in reverse byte order
		Offset      int32  //87
	}
}


func initServerKeys() {
	var err error
	serverPrivKey, err = common.NewPrivateKeyFromHex(serverPrivKeyHex)
	if err != nil {
		panic("Cannot parse Server Private Key from configuration file: " + err.Error())
	}
	//Set server's public key
	serverPubKey = serverPrivKey.Pub
}

func getValidAnchors() {
	es, _ := factom.GetAllChainEntries(anchorChainID.String())

	for _, e := range es {
		validateAndSaveAnchor(e)
	}
}

func validateAndSaveAnchor(e *factom.Entry) {
	if !isAnchorSigned(e.Content) {
		fmt.Println("Anchor record", hex.EncodeToString(e.Hash()), "lacks proper signature")
		return
	}
	//making it this far means that the anchor entry is properly signed

	var anchor AnchorRecord
	justContent := e.Content[:(len(e.Content) - 128)]
	if err := json.Unmarshal(justContent, &anchor); err != nil {
		fmt.Println(err)
		return
	}

	dbmr, err := common.HexToHash(anchor.KeyMR)
	if err != nil {
		fmt.Println(err)
		return
	}

	fetchTry, err := db.FetchDirBlockInfoByHash(dbmr)
	if err != nil || fetchTry == nil {
		dirBlockInfo := &common.DirBlockInfo{}
		dirBlockInfo.DBHash = dbmr
		dirBlockInfo.DBHeight = anchor.DBHeight
		dirBlockInfo.Timestamp = time.Now().Unix()
		dirBlockInfo.DBMerkleRoot = dbmr
		dirBlockInfo.BTCConfirmed = true
		btcTxHash, err := common.HexToHash(anchor.Bitcoin.TXID)
		if err != nil {
			fmt.Println(err)
			return
		}
		btcBlockHash, err := common.HexToHash(anchor.Bitcoin.BlockHash)
		if err != nil {
			fmt.Println(err)
			return
		}
		dirBlockInfo.BTCTxHash = btcTxHash
		dirBlockInfo.BTCBlockHash = btcBlockHash
		dirBlockInfo.BTCBlockHeight = anchor.Bitcoin.BlockHeight
		dirBlockInfo.BTCTxOffset = anchor.Bitcoin.Offset
		db.InsertDirBlockInfo(dirBlockInfo)
	}
}

func isAnchorSigned(entryContent []byte) bool {
	contentString := hex.EncodeToString(entryContent)
	if len(contentString) <= 256 {
		return false
	}
	entryHexString := contentString[:(len(contentString) - 256)]
	sigHexString := contentString[(len(contentString) - 256):]
	signedContent, _ := hex.DecodeString(entryHexString)
	encodedSigContent, _ := hex.DecodeString(sigHexString)
	sigHex, _ := hex.DecodeString(string(encodedSigContent))

	return primitives.SigIsValid(sigHex, cfg.Anchor.AnchorSigPublicKey, signedContent)
}

func main() {
	readConfig()
	anchorLog.Info("Anchormaker: Initializing db...\n")
	initServerKeys()
	initDB(cfg.App.LdbPath)
	fmt.Printf("Anchormaker: Starting synchWithFactomState...\n")

	getValidAnchors()
	//go synchWithFactomState()
	InitAnchor(db, serverPrivKey)
	synchWithFactomState()
}

func synchWithFactomState() {
	for {
		err := loadRemainingBlocks()
		if err != nil {
			fmt.Println(err)
			if strings.HasSuffix(err.Error(), "getsockopt: connection refused") {
				fmt.Printf("\nIn order for anchormaker to synchronize successfully, factomd must be running.\n")
				fmt.Print("Once factomd is running, press 'Enter' to continue...")
				bufio.NewReader(os.Stdin).ReadBytes('\n')
				continue
			} else {
				os.Exit(1)
			}
		}
		time.Sleep(100 * time.Second)
	}
}

func loadRemainingBlocks() error {
	factomHeight, err := factom.GetDBlockHeight()
	if err != nil {
		return err
	}
	//processRemainingAnchors()
	if len(myMonitor.DeepestBlock) == 0 || myMonitor.DeepestBlock == zeroID {
		if myMonitor.Height < factomHeight {
			factomHead, err := factom.GetDBlockHead()
			if err != nil {
				return err
			}

			loadBlocksStartingAt(factomHead.KeyMR)

			myMonitor.Height = factomHeight
			myMonitor.BlockHead = factomHead.KeyMR
			myMonitor.DeepestBlock = zeroID
		}
	} else {
		loadBlocksStartingAt(myMonitor.DeepestBlock)
	}
	//processRemainingAnchors()
	go checkMissingDirBlockInfo()
	return nil
}

func loadBlocksStartingAt(startBlockKeyMR string) {
	saveKeyMR := ""
	nextKeyMR := startBlockKeyMR
	for nextKeyMR != myMonitor.BlockHead && nextKeyMR != zeroID {
		saveKeyMR = (nextKeyMR + " ")[:len(nextKeyMR)]
		nextKeyMR = processBlock(saveKeyMR)
		myMonitor.DeepestBlock = saveKeyMR
	}
	myMonitor.DeepestBlock = zeroID
}

func processBlock(keyMR string) string {
	dblock, err := GetDBlockFromFactom(keyMR)
	if err != nil {
		fmt.Printf("Error getting top dblock from factom: %+v\n", err)
		return dblock.PrevBlockKeyMR
	}

	dblocks = append(dblocks, *dblock)

	return dblock.PrevBlockKeyMR
}

func GetDBlockFromFactom(keyMR string) (*DBlock, error) {
	answer := new(DBlock)

	body, err := factom.GetDBlock(keyMR)
	if err != nil {
		return answer, err
	}

	answer = new(DBlock)
	answer.PrevBlockKeyMR = body.Header.PrevBlockKeyMR
	answer.Timestamp = body.Header.Timestamp
	answer.SequenceNumber = body.Header.SequenceNumber

	answer.KeyMR = keyMR

	return answer, nil
}

func checkMissingDirBlockInfo() {
	//dblocks, _ := db.FetchAllDBlocks()
	dirBlockInfoMap2, err := db.FetchAllDirBlockInfo()
	if err != nil {
		fmt.Println("FETCH DBIM:", err)
	}

	for _, dblock := range dblocks {
		if _, ok := dirBlockInfoMap2[dblock.KeyMR]; ok {
			// anchorLog.Debug("Existing dirBlock.KeyMR", dblock.KeyMR.String())
			continue
		} else {
			dirBlockInfo := &common.DirBlockInfo{}
			dbmr, _ := common.HexToHash(dblock.KeyMR)
			dirBlockInfo.DBHash = dbmr
			dirBlockInfo.DBHeight = uint32(dblock.SequenceNumber)
			dirBlockInfo.Timestamp = int64(dblock.Timestamp * 60) //time.Now().Unix()
			dirBlockInfo.DBMerkleRoot = dbmr
			dirBlockInfo.BTCConfirmed = false
			dirBlockInfo.BTCTxHash = common.NewHash()
			dirBlockInfo.BTCBlockHash = common.NewHash()

			UpdateDirBlockInfoMap(dirBlockInfo)
		}
	}
	//fmt.Println(dirBlockInfoMap)
}


func sanityCheck(hash *common.Hash) (*common.DirBlockInfo, error) {
	dirBlockInfo := dirBlockInfoMap[hash.String()]
	if dirBlockInfo == nil {
		s := fmt.Sprintf("Anchor Error: hash %s does not exist in dirBlockInfoMap.\n", hash.String())
		anchorLog.Error(s)
		return nil, errors.New(s)
	}
	if dirBlockInfo.BTCConfirmed {
		s := fmt.Sprintf("Anchor Warning: hash %s has already been confirmed in btc block chain.\n", hash.String())
		anchorLog.Error(s)
		return nil, errors.New(s)
	}
	if dclient == nil || wclient == nil {
		s := fmt.Sprintf("\n\n$$$ WARNING: rpc clients and/or wallet are not initiated successfully. No anchoring for now.\n")
		anchorLog.Warning(s)
		return nil, errors.New(s)
	}
	if len(balances) == 0 {
		anchorLog.Warning("len(balances) == 0, start rescan UTXO *** ")
		updateUTXO(minBalance)
	}
	if len(balances) == 0 {
		anchorLog.Warning("len(balances) == 0, start rescan UTXO *** ")
		updateUTXO(fee)
	}
	if len(balances) == 0 {
		s := fmt.Sprintf(noBalanceString)
		anchorLog.Warning(s)
		return nil, errors.New(s)
	}
	return dirBlockInfo, nil
}


// InitAnchor inits rpc clients for factom
// and load up unconfirmed DirBlockInfo from leveldb
func InitAnchor(ldb database.Db, serverKey common.PrivateKey) {
	anchorLog.Debug("InitAnchor")
	db = ldb
	serverPrivKey = serverKey
	minBalance, _ = btcutil.NewAmount(0.01)

	var err error
	dirBlockInfoMap, err = db.FetchAllUnconfirmedDirBlockInfo()
	if err != nil {
		anchorLog.Error("InitAnchor error - " + err.Error())
		return
	}
	anchorLog.Debug("init dirBlockInfoMap.len=", len(dirBlockInfoMap))

	// this might take a while to check missing DirBlockInfo for existing DirBlocks in database
	go checkMissingDirBlockInfo()

	if err = InitRPCClient(); err != nil {
		anchorLog.Error(err.Error())
	} else {
		updateUTXO(minBalance)
	}

	ticker0 := time.NewTicker(time.Second * time.Duration(100))
	go func() {
		for _ = range ticker0.C {
			if wclient != nil && dclient != nil {
				checkForAnchor()
			} else {
				anchorLog.Warning("\n\n$$$ WARNING: rpc clients and/or wallet are not initiated successfully. No anchoring for now.\n")
			}
		}
	}()

	ticker := time.NewTicker(time.Minute * time.Duration(tenMinutes))
	go func() {
		for _ = range ticker.C {
			anchorLog.Info("In 10 minutes ticker...")
			readConfig()
			if dclient == nil || wclient == nil {
				if err = InitRPCClient(); err != nil {
					anchorLog.Error(err.Error())
				}
			}
			if wclient != nil {
				checkTxConfirmations()
			}
		}
	}()
}

func readConfig() {
	cfg = readAnchorConfig()

	// setup logger
	logfile, _ := os.OpenFile(cfg.Log.LogPath, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0660)
	anchorLog = factomlog.New(logfile, cfg.Log.LogLevel, "ANCH")
	anchorLog.Info("readConfig")

	confirmationsNeeded = cfg.Anchor.ConfirmationsNeeded
	fee, _ = btcutil.NewAmount(cfg.Btc.BtcTransFee)

	//Added anchor parameters
	var err error
	/*serverECKey, err = common.NewPrivateKeyFromHex(cfg.Anchor.ServerECKey)
	if err != nil {
		panic("Cannot parse Server EC Key from configuration file: " + err.Error())
	}*/
	anchorChainID, err = common.HexToHash(cfg.Anchor.AnchorChainID)
	// anchorLog.Debug("anchorChainID: ", anchorChainID)
	if err != nil || anchorChainID == nil {
		panic("Cannot parse Server AnchorChainID from configuration file: " + err.Error())
	}
	serverPrivKeyHex = cfg.App.ServerPrivKey
}


// ByAmount defines the methods needed to satisify sort.Interface to
// sort a slice of UTXOs by their amount.
type ByAmount []balance

func (u ByAmount) Len() int           { return len(u) }
func (u ByAmount) Less(i, j int) bool { return u[i].unspentResult.Amount < u[j].unspentResult.Amount }
func (u ByAmount) Swap(i, j int)      { u[i], u[j] = u[j], u[i] }

func updateUTXO(base btcutil.Amount) error {
	anchorLog.Info("updateUTXO: base=", base.ToBTC())
	if wclient == nil {
		anchorLog.Info("updateUTXO: wclient is nil")
		return nil
	}
	err := unlockWallet(int64(6)) //600
	if err != nil {
		return fmt.Errorf("%s", err)
	}

	unspentResults, err := wclient.ListUnspentMin(confirmationsNeeded) //minConf=1
	if err != nil {
		return fmt.Errorf("cannot list unspent. %s", err)
	}
	anchorLog.Info("updateUTXO: unspentResults.len=", len(unspentResults))

	if len(unspentResults) > 0 {
		balances = make([]balance, 0, len(unspentResults))
		// var i int
		for _, b := range unspentResults {
			if b.Amount > base.ToBTC() && b.Account != "imported" { //fee.ToBTC()
				balances = append(balances, balance{unspentResult: b})
				// i++
			}
		}
	}
	anchorLog.Info("updateUTXO: balances.len=", len(balances))

	// Sort eligible balances so that we first pick the ones with highest one
	sort.Sort(sort.Reverse(ByAmount(balances)))
	for i, b := range balances {
		addr, err := btcutil.DecodeAddress(b.unspentResult.Address, &chaincfg.TestNet3Params)
		if err != nil {
			return fmt.Errorf("cannot decode address: %s", err)
		}
		balances[i].address = addr

		wif, err := wclient.DumpPrivKey(addr)
		if err != nil {
			return fmt.Errorf("cannot get WIF: %s", err)
		}
		balances[i].wif = wif
		//anchorLog.Infof("balance[%d]=%s \n", i, spew.Sdump(balances[i]))
	}

	if len(balances) > 0 {
		defaultAddress = balances[0].address
	}
	return nil
}

func prependBlockHeight(height uint32, hash []byte) ([]byte, error) {
	// dir block genesis block height starts with 0, for now
	// similar to bitcoin genesis block
	h := uint64(height)
	if 0xFFFFFFFFFFFF&h != h {
		return nil, errors.New("bad block height")
	}
	header := []byte{'F', 'a'}
	big := make([]byte, 8)
	binary.BigEndian.PutUint64(big, h) //height)
	newdata := append(big[2:8], hash...)
	newdata = append(header, newdata...)
	return newdata, nil
}


func saveToAnchorChain(dirBlockInfo *common.DirBlockInfo) {
	anchorLog.Debug("in saveToAnchorChain")
	anchorRec := new(AnchorRecord)
	anchorRec.AnchorRecordVer = 1
	anchorRec.DBHeight = dirBlockInfo.DBHeight
	anchorRec.KeyMR = dirBlockInfo.DBMerkleRoot.String()
	_, recordHeight, _ := db.FetchBlockHeightCache()
	anchorRec.RecordHeight = uint32(recordHeight + 1) // need the next block height
	if defaultAddress != nil {
		anchorRec.Bitcoin.Address = defaultAddress.String()
	}
	anchorRec.Bitcoin.TXID = dirBlockInfo.BTCTxHash.BTCString()
	anchorRec.Bitcoin.BlockHeight = dirBlockInfo.BTCBlockHeight
	anchorRec.Bitcoin.BlockHash = dirBlockInfo.BTCBlockHash.BTCString()
	anchorRec.Bitcoin.Offset = dirBlockInfo.BTCTxOffset
	anchorLog.Info("before submitting Entry To AnchorChain. anchor.record: " + spew.Sdump(anchorRec))

	err := submitEntryToAnchorChain(anchorRec)
	if err != nil {
		anchorLog.Error("Error in writing anchor into anchor chain: ", err.Error())
	}
}

func toHash(txHash *wire.ShaHash) *common.Hash {
	h := new(common.Hash)
	h.SetBytes(txHash.Bytes())
	return h
}

func toShaHash(hash *common.Hash) *wire.ShaHash {
	h, _ := wire.NewShaHash(hash.Bytes())
	return h
}

// UpdateDirBlockInfoMap allows factom processor to update DirBlockInfo
// when a new Directory Block is saved to db
func UpdateDirBlockInfoMap(dirBlockInfo *common.DirBlockInfo) {
	//anchorLog.Debug("UpdateDirBlockInfoMap: ", spew.Sdump(dirBlockInfo))
	dirBlockInfoMap[dirBlockInfo.DBMerkleRoot.String()] = dirBlockInfo
}

func checkForAnchor() {
	anchorLog.Debug("checkForAnchor: map.len=", len(dirBlockInfoMap))
	timeNow := time.Now().Unix()
	time0 := 60 * 60 * reAnchorAfter
	dirBlockInfos := make([]*common.DirBlockInfo, 0, len(dirBlockInfoMap))
	for _, v := range dirBlockInfoMap {
		dirBlockInfos = append(dirBlockInfos, v)
	}
	// anchor the latest dir block first
	sort.Sort(sort.Reverse(ByTimestamp(dirBlockInfos)))
	for _, dirBlockInfo := range dirBlockInfos {
		if bytes.Compare(dirBlockInfo.BTCTxHash.Bytes(), common.NewHash().Bytes()) == 0 {
			anchorLog.Debug("first time anchor: ", spew.Sdump(dirBlockInfo))
			_, err := SendRawTransactionToBTC(dirBlockInfo.DBMerkleRoot, dirBlockInfo.DBHeight)
			if err != nil && strings.Compare(err.Error(), noBalanceString) == 0 {
				break
			}
		} else {
			// This is the re-anchor case for the missed callback or malleated tx,
			// that is, it has BTCTxHash and/or BTCBlockHash, BTCBlockHeight etc but
			// BTCConfirm is false.
			lapse := timeNow - dirBlockInfo.Timestamp
			if lapse > int64(time0) {
				anchorLog.Debugf("re-anchor: time lapse=%d, %s\n", lapse, spew.Sdump(dirBlockInfo))
				_, err := SendRawTransactionToBTC(dirBlockInfo.DBMerkleRoot, dirBlockInfo.DBHeight)
				if err != nil && strings.Compare(err.Error(), noBalanceString) == 0 {
					break
				}
			}
		}
	}
}

func checkTxConfirmations() {
	timeNow := time.Now().Unix()
	time1 := 60 * 5 * confirmationsNeeded
	dirBlockInfos := make([]*common.DirBlockInfo, 0, len(dirBlockInfoMap))
	for _, v := range dirBlockInfoMap {
		if bytes.Compare(v.BTCTxHash.Bytes(), common.NewHash().Bytes()) != 0 {
			dirBlockInfos = append(dirBlockInfos, v)
		}
	}
	sort.Sort(ByTimestamp(dirBlockInfos))
	for _, dirBlockInfo := range dirBlockInfos {
		lapse := timeNow - dirBlockInfo.Timestamp
		if lapse > int64(time1) {
			anchorLog.Debugf("checkTxConfirmations: time lapse=%d", lapse)
			checkConfirmations(dirBlockInfo)
		}
	}
}

func checkConfirmations(dirBlockInfo *common.DirBlockInfo) error {
	anchorLog.Debug("check Confirmations for btc tx: ", toShaHash(dirBlockInfo.BTCTxHash).String())
	txResult, err := wclient.GetTransaction(toShaHash(dirBlockInfo.BTCTxHash))
	if err != nil {
		anchorLog.Debugf(err.Error())
		return err
	}
	anchorLog.Debugf("GetTransactionResult: %s\n", spew.Sdump(txResult))
	if txResult.Confirmations >= int64(confirmationsNeeded) {
		btcBlockHash, _ := wire.NewShaHashFromStr(txResult.BlockHash)
		var rewrite = false
		// Either the call back is not recorded in case of BTCBlockHash is zero hash,
		// or bad things like re-organization of btc main chain happened
		if bytes.Compare(dirBlockInfo.BTCBlockHash.Bytes(), btcBlockHash.Bytes()) != 0 {
			anchorLog.Debugf("BTCBlockHash changed: original BTCBlockHeight=%d, original BTCBlockHash=%s, original tx offset=%d\n", dirBlockInfo.BTCBlockHeight, toShaHash(dirBlockInfo.BTCBlockHash).String(), dirBlockInfo.BTCTxOffset)
			dirBlockInfo.BTCBlockHash = toHash(btcBlockHash)
			btcBlock, err := wclient.GetBlockVerbose(btcBlockHash, true)
			if err != nil {
				anchorLog.Debugf(err.Error())
			}
			if btcBlock.Height > 0 {
				dirBlockInfo.BTCBlockHeight = int32(btcBlock.Height)
			}
			anchorLog.Debugf("BTCBlockHash changed: new BTCBlockHeight=%d, new BTCBlockHash=%s, btcBlockVerbose.Height=%d\n", dirBlockInfo.BTCBlockHeight, btcBlockHash.String(), btcBlock.Height)
			rewrite = true
		}
		dirBlockInfo.BTCConfirmed = true // needs confirmationsNeeded (20) to be confirmed.
		dirBlockInfo.Timestamp = time.Now().Unix()
		db.InsertDirBlockInfo(dirBlockInfo)
		delete(dirBlockInfoMap, dirBlockInfo.DBMerkleRoot.String()) // delete it after confirmationsNeeded (20)
		anchorLog.Debugf("Fully confirmed %d times. txid=%s, dirblockInfo=%s\n", txResult.Confirmations, txResult.TxID, spew.Sdump(dirBlockInfo))
		if rewrite {
			anchorLog.Debug("rewrite to anchor chain: ", spew.Sdump(dirBlockInfo))
			go saveToAnchorChain(dirBlockInfo)
		}
	}
	return nil
}

// ByTimestamp defines the methods needed to satisify sort.Interface to
// sort a slice of DirBlockInfo by their Timestamp.
type ByTimestamp []*common.DirBlockInfo

func (u ByTimestamp) Len() int { return len(u) }
func (u ByTimestamp) Less(i, j int) bool {
	if u[i].Timestamp == u[j].Timestamp {
		return u[i].DBHeight < u[j].DBHeight
	}
	return u[i].Timestamp < u[j].Timestamp
}
func (u ByTimestamp) Swap(i, j int) { u[i], u[j] = u[j], u[i] }

func checkTxMalleation(transaction *btcutil.Tx, details *btcjson.BlockDetails) {
	anchorLog.Debug("in checkTxMalleation")
	dirBlockInfos := make([]*common.DirBlockInfo, 0, len(dirBlockInfoMap))
	for _, v := range dirBlockInfoMap {
		// find those already anchored but no call back yet
		if v.BTCBlockHeight == 0 && bytes.Compare(v.BTCTxHash.Bytes(), common.NewHash().Bytes()) != 0 {
			dirBlockInfos = append(dirBlockInfos, v)
		}
	}
	sort.Sort(ByTimestamp(dirBlockInfos))
	anchorLog.Debugf("malleated tx candidate count=%d, dirBlockInfo list=%s\n", len(dirBlockInfos), spew.Sdump(dirBlockInfos))
	for _, dirBlockInfo := range dirBlockInfos {
		tx, err := wclient.GetRawTransaction(toShaHash(dirBlockInfo.BTCTxHash))
		if err != nil {
			anchorLog.Debugf(err.Error())
			continue
		}
		anchorLog.Debugf("GetRawTransaction=%s, dirBlockInfo=%s\n", spew.Sdump(tx), spew.Sdump(dirBlockInfo))
		// compare OP_RETURN
		if reflect.DeepEqual(transaction.MsgTx().TxOut[0], tx.MsgTx().TxOut[0]) {
			anchorLog.Debugf("Tx Malleated: original.txid=%s, malleated.txid=%s\n", dirBlockInfo.BTCTxHash.BTCString(), transaction.Sha().String())
			doSaveDirBlockInfo(transaction, details, dirBlockInfo, true)
			break
		}
	}
}

//Construct the entry and submit it to the server
func submitEntryToAnchorChain(aRecord *AnchorRecord) error {
	//Marshal aRecord into json
	jsonARecord, err := json.Marshal(aRecord)
	anchorLog.Debug("submitEntryToAnchorChain - jsonARecord: ", string(jsonARecord))
	if err != nil {
		return err
	}
	bufARecord := new(bytes.Buffer)
	bufARecord.Write(jsonARecord)
	//Sign the json aRecord with the server key
	aRecordSig := serverPrivKey.Sign(jsonARecord)
	//Encode sig into Hex string
	bufARecord.Write([]byte(hex.EncodeToString(aRecordSig.Sig[:])))

	entry := factom.NewEntry()
	entry.ChainID = cfg.Anchor.AnchorChainID
	entry.Content = bufARecord.Bytes()
	err = primitives.JustFactomize(entry, cfg.Anchor.ServerECKey)

	return err
}

// MilliTime returns a 6 byte slice representing the unix time in milliseconds
func milliTime() (r []byte) {
	buf := new(bytes.Buffer)
	t := time.Now().UnixNano()
	m := t / 1e6
	binary.Write(buf, binary.BigEndian, m)
	return buf.Bytes()[2:]
}
